访问地址：http://www.jianshu.com/p/ef18af5a9c1d


项目中，因为使用了第三方支付（支付宝和微信支付），支付完毕后，第三方支付平台一般会采用异步回调通知的方式，通知商户支付结果，然后商户根据通知内容，变更商户项目支付订单的状态。一般来说，为了防止商户项目自身因为一些特殊原因，比如正好当时网络状态不稳定，商户回调接口无法访问，或者商户回调接口出现异常。第三方支付平台，一般会发送多次请求来尽量确保通知到商户系统。

但是，总会有各种各样的情况，导致，第三方平台所有的通知次数通知完毕后，商户系统依然没有正确处理掉改笔订单状态。（一般第三方支付平台，会：1分钟，10分钟，1小时，6小时，12小时，24小时通知商户支付接口，当然这个时间只是举例而已，实际的通知时间会和这个不太一样，但是也是大致的意思）。当如果按这个频次通知完毕后，第三方支付平台就不再进行通知了。

所以，一旦第三方支付平台，将通知次数发送完毕后，平台依然没有处理好自己项目的订单状态，那么订单状态很可能是，客户实际已经完成支付，但是自己项目这边依然显示：“等待支付”这样的状态。那么为了解决这类问题，一般，我们会采用定时任务的方式，比如1个小时，我们把订单支付已经超过1小时，但是还没超过24小时的订单去第三方平台主动的查询一次订单状态。避免因为自己原因，导致的订单状态不一致的情况。这类设置已经超过1小时，未超过24小时的原因，主要是为了查询效率，因为半小时之内还未支付，我们认为实际中存在这个可能性，所以可以等到1个小时，在查状态，而不超过24小时的原因是，一旦超过24小时，我们可以认为订单实际上已经超时失败了，如果查这个订单，就会导致，每次定时任务都会把之前已经查过的订单，在反复的查询。造成大量不必要的查询。一般我们也会在启一个定时任务，24小时执行一次，把一些订单重置为失败。减少不必要的失败订单的反复查询。




下面进入正题，在spring boot中，如何来处理定时任务。
默认，springboot已经支持了定时任务Schedule模块，所以一般情况已经完全能够满足我们的实际需求，一般来说，没有必要在加入其他类似于：quartz

另外，在这里提一个实际项目中，关于定时任务的架构上的一些考虑：

一般来说，实际项目中，为了提高服务的响应能力，我们一般会通过负载均衡的方式，或者反向代理多个节点的方式来进行。通俗点来说，我们一般会将项目部署多实例，或者说部署多份，每个实例不同的启动端口。但是每个实例的代码其实都是一样的。如果我们将定时任务写在我们的项目中，就会面临一个麻烦，就是比如我们部署了3个实例，三个实例一启动，就会把定时任务都启动，那么在同一个时间点，定时任务会一起执行，也就是会执行3次，这样很可能会导致我们的业务出现错误。

一般来说，我们有几种简单的办法来处理：

1、配置文件中增加自定义配置，通过开关来进行控制：比如增加：schedule=enable , schedule=disable，这样在我们的实际代码中，在进行判断，也就是我们可以通过配置，达到，只有一个实例真正执行定时任务，其他的是实例不执行。但是，这种做法实际是还是定时任务都启动，只是在执行中，我们人工来进行判断，执行于不执行真正的处理逻辑。
2、逻辑分离，就是我们将真正要定时任务处理的逻辑，写成rest服务，或者rpc服务，然后我们可以新建一个单独的定时任务项目，这个项目应该是没有任何的业务代码的，他纯粹只有定时任务功能，几点启动，或者每隔多少时间启动，启动后，通过rest或者rpc的方式，调用真正处理逻辑的服务。同时，我们甚至可以不用新建一个项目，我们通过linux的cron就可以进行。同时，这种方式还有一个好处，比如有些时候，我们的定时任务也会因为某些原因出现问题，没有执行，那么我们就可以通过curl 或者wget等等很多方式，再次定时任务的执行。

所以，个人一般偏向使用第二种方式，达到定时任务和业务处理的分离。

而在spring boot中，如何使用定时任务，相对比较简单。按第二种方式，实际上，我需要新建一个项目来完成定时任务的功能，其实，我们完全可以新建一个普通的java项目，引入quartz来达到，但是这里，我是通过spring boot来完成，新建一个spring boot项目，项目的初始化可以使用：http://start.spring.io

初始化之后，我们在spring boot的入口类Application.java中，允许支持schedule

@SpringBootApplication
@EnableScheduling
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}
然后，新建一个执行类Jobs.java

@Component
public class Jobs {
    public final static long ONE_Minute =  60 * 1000;

    @Scheduled(fixedDelay=ONE_Minute)
    public void fixedDelayJob(){
        System.out.println(Dates.format_yyyyMMddHHmmss(new Date())+" >>fixedDelay执行....");
    }

    @Scheduled(fixedRate=ONE_Minute)
    public void fixedRateJob(){
        System.out.println(Dates.format_yyyyMMddHHmmss(new Date())+" >>fixedRate执行....");
    }

    @Scheduled(cron="0 15 3 * * ?")
    public void cronJob(){
        System.out.println(Dates.format_yyyyMMddHHmmss(new Date())+" >>cron执行....");
    }
}
这是最简单的2种方式，多少分钟执行一次，fixedDelay和fixedRate，单位是毫秒，所以1分钟就是60秒×1000
他们的区别在于，fixedRate就是每多次分钟一次，不论你业务执行花费了多少时间。我都是1分钟执行1次，而fixedDelay是当任务执行完毕后1分钟在执行。所以根据实际业务不同，我们会选择不同的方式。

而还有一类定时任务，比如是每天的3点15分执行，那么我们就需要用另外一种方式：cron表达式

cron表达式，有专门的语法，而且感觉有点绕人，不过简单来说，大家记住一些常用的用法即可，特殊的语法可以单独去查。
cron一共有7位，但是最后一位是年，可以留空，所以我们可以写6位：

* 第一位，表示秒，取值0-59
* 第二位，表示分，取值0-59
* 第三位，表示小时，取值0-23
* 第四位，日期天/日，取值1-31
* 第五位，日期月份，取值1-12
* 第六位，星期，取值1-7，星期一，星期二...，注：不是第1周，第二周的意思
          另外：1表示星期天，2表示星期一。
* 第7为，年份，可以留空，取值1970-2099
cron中，还有一些特殊的符号，含义如下：

(*)星号：可以理解为每的意思，每秒，每分，每天，每月，每年...
(?)问号：问号只能出现在日期和星期这两个位置，表示这个位置的值不确定，每天3点执行，所以第六位星期的位置，我们是不需要关注的，就是不确定的值。同时：日期和星期是两个相互排斥的元素，通过问号来表明不指定值。比如，1月10日，比如是星期1，如果在星期的位置是另指定星期二，就前后冲突矛盾了。
(-)减号：表达一个范围，如在小时字段中使用“10-12”，则表示从10到12点，即10,11,12
(,)逗号：表达一个列表值，如在星期字段中使用“1,2,4”，则表示星期一，星期二，星期四
(/)斜杠：如：x/y，x是开始值，y是步长，比如在第一位（秒） 0/15就是，从0秒开始，每15秒，最后就是0，15，30，45，60    另：*/y，等同于0/y
下面列举几个例子供大家来验证：

0 0 3 * * ?     每天3点执行
0 5 3 * * ?     每天3点5分执行
0 5 3 ? * *     每天3点5分执行，与上面作用相同
0 5/10 3 * * ?  每天3点的 5分，15分，25分，35分，45分，55分这几个时间点执行
0 10 3 ? * 1    每周星期天，3点10分 执行，注：1表示星期天
0 10 3 ? * 1#3  每个月的第三个星期，星期天 执行，#号只能出现在星期的位置

作者：陶清清
链接：http://www.jianshu.com/p/ef18af5a9c1d
來源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。